{"meta":{"title":"饭饭的博客","subtitle":"面朝大海，春暖花开","description":"ALL IN","author":"Albert-Peng","url":"www.yoursite"},"pages":[{"title":"about","date":"2017-03-08T13:38:39.000Z","updated":"2017-03-13T07:34:12.560Z","comments":true,"path":"about/index.html","permalink":"www.yoursite/about/index.html","excerpt":"","text":"大学仪器专业 干过工业控制 硕士读电子与通信 决心当一名程序猿 生命不止 折腾不止 哇哈哈 祝我能有一个好结果 找到心仪的工作 阿门 Email：pxwhit@163.comWechat:peerless1992github:github.com/Albert_Peng"},{"title":"tags","date":"2017-03-13T07:02:43.000Z","updated":"2017-03-13T07:03:57.717Z","comments":true,"path":"tags/index.html","permalink":"www.yoursite/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-03-13T05:48:56.000Z","updated":"2017-03-13T07:06:53.480Z","comments":true,"path":"categories/index.html","permalink":"www.yoursite/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Java虚拟机-垃圾收集算法","slug":"Java虚拟机-垃圾收集器与内存分配策略","date":"2017-03-14T12:59:22.000Z","updated":"2017-03-14T14:10:38.561Z","comments":true,"path":"2017/03/14/Java虚拟机-垃圾收集器与内存分配策略/","link":"","permalink":"www.yoursite/2017/03/14/Java虚拟机-垃圾收集器与内存分配策略/","excerpt":"","text":"垃圾收集与内存分配研究的主要问题主要问题 什么垃圾需要回收和哪些垃圾需要回收（垃圾的标记） 如何回收垃圾（垃圾回收方法） 如何有效地分配内存##哪些区域需要实现垃圾收集 ## 垃圾的判定引用计数法引用计数法的原理给每一个对象添加一个对象引用计数器，每当对象有一个新的引用时，引用计数器加1。反过来，每当有一个引用失效时，即减1。当引用计数器值为0，则对象已经没有引用，可以进行垃圾回收。 引用计数法的优缺点优点是计算简单，效率高；缺点是很难解决对象之间相互循环引用的问题。 可达性分析算法（Reachability Analysis）可达性分析算法的原理可达性分析算法的原理是通过一系列的“GC Roots”作为根节点，向下进行搜索，没有搜索到的对象就是不可达的，即证明这个对象是不可用的。如下图所示，objectD和objectE就是不可达的。常作为GC Roots的对象： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（Native）引用的对象 Java中引用的分类强引用 （Strong Reference）就是指在程序代码之中普遍存在的，类似 “Object obj = new Object()” 这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。 软引用（Soft Reference）是用来描述一些还有用但并非需要的对象，对于软引用关联着的对象，在系统将要发生内存异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存异常 弱引用（Weak Reference）也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存岛下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存释放足够，都会回收掉只被弱引用关联的对象 虚引用称为幽灵引用或者幻影引用，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，对一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知 方法区的垃圾回收Java虚拟机不要求虚拟机在方法区实现垃圾收集，而且在方法区中的垃圾收集的性价比较低；在堆中，尤其在新生代中的回收70-90%的空间，而方法区（永久代）的垃圾回收效率远低于此。方法区主要回收废弃常量和无用类。 垃圾收集算法标记-清除算法（Mark-Sweep）标记-清除算法原理首先对垃圾进行标记，然后在根据标记清除垃圾。 缺点 效率不高，标记和清除两个过程的效率都不高 标记清除之后，会产生大量不连续的内存碎片，导致在内存分配时，大对象不能分配足够的连续内存，而触发下一次垃圾收集。 复制算法原理将内存分为两部分，先使用其中一部分，当使用的这部分将要用完时，复制还存活的对象到另一部分内存中，统一清除原来的内存空间。实际上，由两个survivor区域和一个Eden区域组成。 优缺点 算法简单，高效 不会产生大量空间碎片 内存浪费 标记和整理算法（Mark-Compact）首先标记，然后让存活的对象统一向内存一端移动，最后再清楚边界外的内存。 分代收集算法（Generational Collection）根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。 在New Generation块中，垃圾回收一般用复制算法，速度快。每次GC的时候，存活下来的对象首先由Eden拷贝到某个Survivor Space, 当Survivor Space空间满了后, 剩下的live对象就被直接拷贝到Old Generation中去。因此，每次GC后，Eden内存块会被清空。 在Old Generation块中，垃圾回收一般用标记整理的算法，速度慢些，但减少内存要求. 垃圾回收分多级，0级为全部(Full)的垃圾回收，会回收Old段中的垃圾；1级或以上为部分垃圾回收，只会回收New中的垃圾，内存溢出通常发生于Old段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。 引用： 《深入理解Java虚拟机-JVM高级特性与最佳实践》 周志明著http://blog.csdn.net/jiangwei0910410003/article/details/40709457","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"www.yoursite/categories/Java虚拟机/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"www.yoursite/tags/JVM/"}]},{"title":"Java虚拟机-运行时数据区域","slug":"Java虚拟机-运行时数据区域","date":"2017-03-13T08:51:52.000Z","updated":"2017-03-13T09:04:10.267Z","comments":true,"path":"2017/03/13/Java虚拟机-运行时数据区域/","link":"","permalink":"www.yoursite/2017/03/13/Java虚拟机-运行时数据区域/","excerpt":"","text":"Java虚拟机运行时数据区域运行时数据区域的总体框架Java的运行时数据区域主要由Java堆、方法区和Java虚拟机栈本地方法栈和程序计数器组成。如图所示是Java虚拟机JVM的运行时数据区域框架图。 程序计数器程序计数器可以看成当前线程的字节码行号指示器，程序计数器指示字节码解释器的下一条需要执行的字节码指令。如果线程正在执行一个Java方法，则程序计数器将指向正在执行的虚拟机字节码指令地址；如果正在执行的是native方法，则这个程序计数器将为空。程序计数器不存在OutOfMemoryError。 Java虚拟机栈Java（Java Virtual Machine Stacks）虚拟机栈时线程独享的，其生命周期与线程的生命周期相同。虚拟机栈描述的是Java方法执行的内存模型：每一个方法在执行的同时会创建一个栈帧（Stack Frame）由于存储局部变量表、操作数栈、动态链接和方法出口等。每一个方法从执行到调用对应着一个栈帧的入栈和出栈的过程。Stack Frame是Java虚拟机栈的基本单位。局部变量表存放了编译期可知的基本数据类型和对象引用类型。在此区域存在两种异常状况：StackOverflowError和OutOfMemoryError两种错误。 1.4 本地方法栈（Native Method Stack）本地方法栈和虚拟机栈的作用非常类似，区别在于虚拟机栈是虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。 Java堆（Java Heap）Java堆（Java 堆）是Java虚拟机所管理的内存最大的一块，Java堆是线程共享的内存区域，在虚拟机启动时创建，唯一的目的是存放对象的实例。Java堆是Java垃圾收集器管理的主要区域，由于现在的垃圾收集器基本采用分代收集算法，因此Java堆可以分为新生代和老年代。Java堆中也可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer）。Java堆可以处于物理上不连续的内存空间上，只要逻辑内存连续即可。 Java方法区（Method Area）方法区也是线程共享的，用于存储已经被虚拟机加载的类信息、常量、静态变量和即时编译后的代码等数据。Java方法区不需要连续的内存、可以扩展，还可以选择不实现垃圾收集。方法区不能满足内存分配需求时会出现OutOfMemoryError。 运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译期生成的各种字面量和符号引用，比如字符串常量。 1.7 直接内存直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也可能导致OutOfMemory。 Hotspot虚拟机对象初探对象的创建Java进行对象的过程大致分为以下几个步骤： 虚拟机遇到一条new指令首先会检查要new的对象类是否已经加载在虚拟中，检查的方法是在常量池中检查是否有没有目标类名的符号引用，如果没有则进行类的加载、解析和初始化。 类加载检查通过后，将为新生对象在Java堆中分配内存（指针碰撞和空闲列表），需要考虑到线程同步问题，解决的方法是线程同步分配内存，另外可以给每一个线程单独分配一块线程独立的内存区域（本地线程分配缓冲，TLAB）。 内存分配完成后，虚拟机将对分配的内存空间初始化为零并进行相关设置。 执行Java方法的init方法，对象创建完成。对象内存分布对象的内存分布，是指一个对象在内存中的存储布局，主要分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。对象头主要包括两个部分，第一部分用于存储对象自身运行时数据，如哈希码（Hash Code）、GC分带年龄、指向锁记录的指针等信息；第二部分是类型指针，即对象指向自身的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 实例数据是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。 对齐填充，起到占位的作用，使得占用的内存大小为8的整数倍。 2.3 对象的访问定位对象的定位是指Java虚拟机栈的reference引用定位到Java堆中的对象，有两种方式：句柄访问和直接访问。","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"www.yoursite/categories/Java虚拟机/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"www.yoursite/tags/JVM/"}]},{"title":"Java基础总结-01","slug":"Java基础总结-01","date":"2017-03-13T08:48:45.000Z","updated":"2017-03-13T09:04:55.930Z","comments":true,"path":"2017/03/13/Java基础总结-01/","link":"","permalink":"www.yoursite/2017/03/13/Java基础总结-01/","excerpt":"","text":"static关键字和private关键字 static修饰成员变量和成员方法表示成员变量和方法为类所有，所有此类的实例都可以对其进行访问。Java中的static方法不能子类override（覆盖），因为方法覆盖是基于运行时动态绑定的，而static方法和成员变量都是编译时静态绑定的，static方法和成员变量在Java虚拟机载入类时对其进行了初始化和加载，在此类的实例被创建之前就已经被载入虚拟机。因此，static不能被overrid。再进一步，static方法也不能在非static变量和方法被创建前就对其进行访问，只能通过实例访问，因为在类的实例被创建前，非static成员变量和方法还未被创建。 private修饰符只能是类和类的实例可以访问，不能被override。 Java自动拆箱和装箱 定义 自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类byte,short,char,int,long,float,double和boolean对应的封装类为Byte,Short,Character,Integer,Long,Float,Double,Boolean。 自动拆箱和装箱的方法实现 (1)自动装箱：把基本类型用它们对应的引用类型包装起来，使它们具有对象的特质，可以调用toString()、hashCode()、getClass()、equals()等方法。 如下： Integer a=3;//这是自动装箱 其实编译器调用的是static Integer valueOf(int i)这个方法,valueOf(int i)返回一个表示指定int值的Integer对象,那么就变成这样: Integer a=3; =&gt; Integer a=Integer.valueOf(3); (2)拆箱：跟自动装箱的方向相反，将Integer及Double这样的引用类型的对象重新简化为基本类型的数据。 如下： int i = new Integer(2);//这是拆箱 编译器内部会调用int intValue()返回该Integer对象的int值 自动拆箱和装箱出现的情况 （1）赋值情况，初始化数据类型被赋值给对象类型以及相反的情况就会发生自动装箱和拆箱；（2）方法调用，方法参数是对象类型但传入的是初始数据类型也会发生自动拆箱和装箱；（3）尽量在程序中避免频繁的拆箱和装箱 “==”和equals() 方法“==”对于基本数据类型而言，是比较两个变量的值是否一样；对于对象而言，是比较对象在堆中的内存是否一致。“equals（）”是objet类中的一个方法，初始行为是比较两个对象的内存地址是否一致，但是String，Integer等类都对equals方法进行了overr重写，变成比较值的大小。 public class AutoboxingTest { public static void main(String args[]) { // Example 1: == comparison pure primitive – no autoboxing int i1 = 1; int i2 = 1; System.out.println(&quot;i1==i2 : &quot; + (i1 == i2)); // true // Example 2: equality operator mixing object and primitive Integer num1 = 1; // autoboxing int num2 = 1; System.out.println(&quot;num1 == num2 : &quot; + (num1 == num2)); // true // Example 3: special case - arises due to autoboxing in Java Integer obj1 = 1; // autoboxing will call Integer.valueOf() Integer obj2 = 1; // same call to Integer.valueOf() will return same // cached Object System.out.println(&quot;obj1 == obj2 : &quot; + (obj1 == obj2)); // true // Example 4: equality operator - pure object comparison Integer one = new Integer(1); // no autoboxing Integer anotherOne = new Integer(1); System.out.println(&quot;one == anotherOne : &quot; + (one == anotherOne)); // false } } Output: i1==i2 : true num1 == num2 : true obj1 == obj2 : true one == anotherOne : false 值得注意的是第三个小例子，这是一种极端情况。obj1和obj2的初始化都发生了自动装箱操作。但是处于节省内存的考虑，JVM会缓存-128到127的Integer对象。因为obj1和obj2实际上是同一个对象。所以使用”==“比较返回true。类似的例子还有字符串常量池。 字符串常量池Java中字符串对象创建有两种形式。 String str = &quot;droid&quot;;//字面量式创建方法 String str = new String(&quot;droid&quot;);//new创建方法 JVM为了减少字符串对象的重复创建，其维护了一个特殊的内存，这段内存被成为字符串常量池或者字符串字面量池。当代码中出现字面量形式创建字符串对象时，JVM首先会对这个字面量进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回，否则新的字符串对象被创建，然后将这个引用放入字符串常量池，并返回该引用。 当我们使用了new来构造字符串对象的时候，不管字符串常量池中有没有相同内容的对象的引用，新的字符串对象都会创建。对于上面使用new创建的字符串对象，如果想将这个对象的引用加入到字符串常量池，可以使用intern方法。调用intern后，首先检查字符串常量池中是否有该对象的引用，如果存在，则将这个引用返回给变量，否则将引用加入并返回给变量。 String str4 = str3.intern(); System.out.println(str4 == str1); 输出的结果为true。 字符串常量池中存放的时引用还是对象，这个问题是最常见的。字符串常量池存放的是对象引用，不是对象。在Java中，对象都创建在堆内存中。字符串常量池的好处就是减少相同内容字符串的创建，节省内存空间。如果硬要说弊端的话，就是牺牲了CPU计算时间来换空间。CPU计算时间主要用于在字符串常量池中查找是否有内容相同对象的引用。不过其内部实现为HashTable，所以计算成本较低。 Override（覆盖、重写）和overload（重载）Override是子类继承父类的方法，返回值类型、方法名和参数列表必须一致，访问权限修饰符可以不一致，但是只能将访问范围扩大，不能缩小。 构建方法的override 子类不能继承父类的构造方法，只是会调用父类的构造方法，分为显式和隐式调用； 父类中无构造方法或者只有一个无参数构造方法，那么子类会自动隐式调用父类的构造方法； 父类只有有参数构造函数，子类需要显示调用父类的构造方法，否则编译出错； 父类既有无参数构造方法也有带参数构造方法，子类可以显示调用，也可以不显式调用，此时默认调用父类无参数构造方法。 Overload方法名必须一致，参数必须不一样，但返回值类型和修饰符可以不一样。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"www.yoursite/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"www.yoursite/tags/Java/"}]}]}